From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bjarne Koll <lynxplay101@gmail.com>
Date: Fri, 5 Nov 2021 17:20:50 +0100
Subject: [PATCH] Implement a lists for persistent data containers

Introduces the concepts of lists to the persistent data container and
its persistent data container types. To properly represent lists, two
new list types are introduced, one that is properly typed using the
persistent data type framework and one that remains untyped.

diff --git a/src/main/java/org/bukkit/persistence/PersistentDataType.java b/src/main/java/org/bukkit/persistence/PersistentDataType.java
index b27f4568c21d0f75bc10e76c104c749e81194794..8efcce38e3b322d0d985c6ce3c3deac764e27df7 100644
--- a/src/main/java/org/bukkit/persistence/PersistentDataType.java
+++ b/src/main/java/org/bukkit/persistence/PersistentDataType.java
@@ -1,6 +1,7 @@
 package org.bukkit.persistence;
 
 import org.jetbrains.annotations.NotNull;
+import java.util.List;
 
 /**
  * This class represents an enum with a generic content type. It defines the
@@ -87,6 +88,13 @@ public interface PersistentDataType<T, Z> {
      */
     PersistentDataType<PersistentDataContainer, PersistentDataContainer> TAG_CONTAINER = new PrimitivePersistentDataType<>(PersistentDataContainer.class);
 
+    // Paper start - pdc list type
+    /*
+        Lists of persistent data types.
+     */
+    ListPersistentDataTypeFactory LIST = new ListPersistentDataTypeFactory();
+    // Paper end - pdc list type
+
     /**
      * Returns the primitive data type of this tag.
      *
@@ -118,7 +126,7 @@ public interface PersistentDataType<T, Z> {
      * Creates a complex object based of the passed primitive value
      *
      * @param primitive the primitive value
-     * @param context the context this operation is running in
+     * @param context   the context this operation is running in
      * @return the complex object instance
      */
     @NotNull
@@ -197,4 +205,68 @@ public interface PersistentDataType<T, Z> {
             return primitive != 0;
         }
     }
+
+    class ListPersistentDataTypeFactory {
+        private static final ListPersistentDataType<Byte, Byte> BYTE = new ListPersistentDataType<>(PersistentDataType.BYTE);
+        private static final ListPersistentDataType<Short, Short> SHORT = new ListPersistentDataType<>(PersistentDataType.SHORT);
+        private static final ListPersistentDataType<Integer, Integer> INTEGER = new ListPersistentDataType<>(PersistentDataType.INTEGER);
+        private static final ListPersistentDataType<Long, Long> LONG = new ListPersistentDataType<>(PersistentDataType.LONG);
+        private static final ListPersistentDataType<Float, Float> FLOAT = new ListPersistentDataType<>(PersistentDataType.FLOAT);
+        private static final ListPersistentDataType<Double, Double> DOUBLE = new ListPersistentDataType<>(PersistentDataType.DOUBLE);
+        private static final ListPersistentDataType<Byte, Boolean> BOOLEAN = new ListPersistentDataType<>(PersistentDataType.BOOLEAN);
+        private static final ListPersistentDataType<String, String> STRING = new ListPersistentDataType<>(PersistentDataType.STRING);
+        private static final ListPersistentDataType<byte[], byte[]> BYTE_ARRAY = new ListPersistentDataType<>(PersistentDataType.BYTE_ARRAY);
+        private static final ListPersistentDataType<int[], int[]> INTEGER_ARRAY = new ListPersistentDataType<>(PersistentDataType.INTEGER_ARRAY);
+        private static final ListPersistentDataType<long[], long[]> LONG_ARRAY = new ListPersistentDataType<>(PersistentDataType.LONG_ARRAY);
+        private static final ListPersistentDataType<PersistentDataContainer[], PersistentDataContainer[]> TAG_CONTAINER_ARRAY = new ListPersistentDataType<>(PersistentDataType.TAG_CONTAINER_ARRAY);
+        private static final ListPersistentDataType<PersistentDataContainer, PersistentDataContainer> TAG_CONTAINER = new ListPersistentDataType<>(PersistentDataType.TAG_CONTAINER);
+
+        public PersistentDataType<TypedListWrapper<Byte, Byte>, List<Byte>> bytes() {
+            return BYTE;
+        }
+
+        public PersistentDataType<TypedListWrapper<Short, Short>, List<Short>> shorts() {
+            return SHORT;
+        }
+
+        public PersistentDataType<TypedListWrapper<String, String>, List<String>> strings() {
+            return STRING;
+        }
+    }
+
+    record TypedListWrapper<P, C>(
+        List<P> primitiveList,
+        PersistentDataType<P,C> primitiveDataType
+    ) {
+
+    }
+
+    record ListPersistentDataType<P, C> (
+        PersistentDataType<P, C> innerType
+    )implements PersistentDataType<TypedListWrapper<P, C>, List<C>> {
+
+        @SuppressWarnings("unchecked")
+        @NotNull
+        @Override
+        public Class<TypedListWrapper<P, C>> getPrimitiveType() {
+            return (Class<TypedListWrapper<P, C>>) (Object) TypedListWrapper.class;
+        }
+
+        @SuppressWarnings("unchecked")
+        @NotNull
+        @Override
+        public Class<List<C>> getComplexType() {
+            return (Class<List<C>>) (Object) List.class;
+        }
+
+        @Override
+        public @NotNull TypedListWrapper<P, C> toPrimitive(@NotNull final List<C> complex, @NotNull final PersistentDataAdapterContext context) {
+            return new TypedListWrapper<>(com.google.common.collect.Lists.transform(complex, s -> innerType.toPrimitive(s, context)), this.innerType);
+        }
+
+        @Override
+        public @NotNull List<C> fromPrimitive(@NotNull final TypedListWrapper<P, C> primitive, @NotNull final PersistentDataAdapterContext context) {
+            return com.google.common.collect.Lists.transform(primitive.primitiveList(), s -> innerType.fromPrimitive(s, context));
+        }
+    }
 }
diff --git a/src/main/java/org/bukkit/persistence/list/PersistentDataList.java b/src/main/java/org/bukkit/persistence/list/PersistentDataList.java
new file mode 100644
index 0000000000000000000000000000000000000000..d235c8d84b41ba18217b53d1d01069ddd1cc9205
--- /dev/null
+++ b/src/main/java/org/bukkit/persistence/list/PersistentDataList.java
@@ -0,0 +1,35 @@
+package org.bukkit.persistence.list;
+
+import java.util.List;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a typed list of persistent data. This list is only a copy of the original list and any modification have
+ * to be fed back to the {@link PersistentDataContainer} to be effective
+ *
+ * @param <E> the generic type of the persistent data stored within
+ */
+public interface PersistentDataList<E> extends UntypedPersistentDataList, List<E> {
+
+    /**
+     * Returns this list instanced typed by the provided data type. As this list instance is already typed, the only
+     * acceptable data type that can be passed is the one used to create this list instance from the {@link
+     * UntypedPersistentDataList}.
+     *
+     * @param dataType the type this list is supposed to be
+     * @param <T> the primitive type the values are stored in before
+     * @param <Z> the generic type of the returned list
+     *
+     * @return this list instance, as it is already typed.
+     *
+     * @throws IllegalArgumentException if the passed primitiveDataType is not the same as the one used to create this list
+     * @deprecated as this list is already typed. The only acceptable call to this is the one used to type this list in
+     * the first place. An instance of any other {@link PersistentDataType}, even when transforming to the same complex
+     * type, will throw an {@link IllegalArgumentException}
+     */
+    @NotNull
+    @Override
+    <T, Z> PersistentDataList<Z> type(@NotNull PersistentDataType<T, Z> dataType);
+}
diff --git a/src/main/java/org/bukkit/persistence/list/UntypedPersistentDataList.java b/src/main/java/org/bukkit/persistence/list/UntypedPersistentDataList.java
new file mode 100644
index 0000000000000000000000000000000000000000..d30d3b65278fdfe2790e66aa214bb6c57e8db3ae
--- /dev/null
+++ b/src/main/java/org/bukkit/persistence/list/UntypedPersistentDataList.java
@@ -0,0 +1,50 @@
+package org.bukkit.persistence.list;
+
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The {@link UntypedPersistentDataList} interface defines an untyped list instance without any specific values. This
+ * instance can not be iterated over yet nor is any access to data granted.
+ */
+public interface UntypedPersistentDataList {
+
+    /**
+     * Returns the size of the list
+     *
+     * @return the size
+     */
+    int size();
+
+    /**
+     * Returns a copy of this list but now with a specific list type. This method will attempt to parse the previously
+     * known list and will fail with an {@link IllegalArgumentException} if either the {@link PersistentDataType} has no
+     * valid adapter or if the list type is not of the passed type.
+     *
+     * @param dataType the type this list is supposed to be
+     * @param <T> the primitive type the values are stored in
+     * @param <Z> the generic java type of the lists content
+     *
+     * @return the list instance
+     *
+     * @throws IllegalArgumentException if the passed primitiveDataType has no suitable adapter
+     * @throws IllegalArgumentException if the passed primitiveDataType does not match the untyped data stored in the list
+     */
+    @NotNull
+    <T, Z> PersistentDataList<Z> type(@NotNull PersistentDataType<T, Z> dataType);
+
+    /**
+     * Returns if the data stored in this data list matches the data accepted by the {@link
+     * PersistentDataType#getPrimitiveType()} and could technically be consumed be it. This method does not test if the
+     * complex data type can be created. If the list is empty, more specifically {@link
+     * UntypedPersistentDataList#size()} is 0, this value will always return true as the list is not typed at all and
+     * can simply by retyped to any primitive type.
+     *
+     * @param dataType the data type to check against
+     * @param <T> the generic java type of the primitive type to check against
+     * @param <Z> the generic java type of the data type
+     *
+     * @return {@code true} if the content in the list can be converted using this {@link PersistentDataType}
+     */
+    <T, Z> boolean isType(@NotNull PersistentDataType<T, Z> dataType);
+}
